import type { Question } from '../types/quiz';

export const questions: Question[] = [
  // Section 1: Architecture & Components
  {
    id: 1,
    section: "Architecture & Components",
    question: "Which component is responsible for performing the actual FHE computations on encrypted ciphertexts?",
    options: [
      "Gateway",
      "KMS (Key Management Service)",
      "Coprocessor",
      "Host Chain"
    ],
    correctAnswer: 2,
    explanation: "The Coprocessor is the off-chain computation engine that executes FHE operations (add, mul, div, cmp, etc.) using the tfhe-rs library. The Host Chain only handles symbolic execution, and the Gateway coordinates but doesn't compute."
  },
  {
    id: 2,
    section: "Architecture & Components",
    question: "The Zama Gateway is implemented as:",
    options: [
      "A Layer 1 blockchain like Ethereum",
      "An Arbitrum optimistic rollup (L2/L3)",
      "A centralized REST API server",
      "A set of IPFS nodes"
    ],
    correctAnswer: 1,
    explanation: "The Gateway is implemented using the Arbitrum stack as an optimistic rollup, with a sequencer operated by Conduit. This provides the coordination layer for the protocol."
  },
  {
    id: 3,
    section: "Architecture & Components",
    question: "Zama's TKMS uses 13 MPC nodes with a corruption threshold of 4. How many node responses are required for User Decryption?",
    options: [
      "5 nodes (t+1)",
      "7 nodes (n/2)",
      "9 nodes (2t+1)",
      "13 nodes (all)"
    ],
    correctAnswer: 2,
    explanation: "User decryption requires 2t+1 = 9 nodes. Each KMS node encrypts its partial decryption share under the user's public key, so only the user can combine them and see the plaintext. This threshold ensures correctness even with t=4 malicious nodes. Public decryption only requires t+1 = 5 nodes since shares are combined on-chain."
  },
  {
    id: 4,
    section: "Architecture & Components",
    question: "Where are the actual FHE ciphertexts stored in the Zama protocol?",
    options: [
      "On the Host Chain (L1) in contract state",
      "In the Gateway smart contracts",
      "In the Coprocessor's local database (Coprocessor DA)",
      "In the user's browser localStorage"
    ],
    correctAnswer: 2,
    explanation: "Ciphertexts are stored off-chain in the Coprocessor DA. Only 32-byte handles (references) are stored on-chain to minimize gas costs. The Gateway stores ciphertext commits (digests/hashes), not the actual ciphertexts."
  },
  {
    id: 5,
    section: "Architecture & Components",
    question: "Which of the following is NOT a Host Chain (L1) smart contract?",
    options: [
      "ACL (Access Control List)",
      "TFHEExecutor",
      "MultichainACL",
      "InputVerifier"
    ],
    correctAnswer: 2,
    explanation: "MultichainACL is a Gateway contract, not a Host Chain contract. It tracks ciphertext ownership and access permissions across multiple chains on the Gateway. The Host Chain has its own ACL contract for local access control."
  },

  // Section 2: Data Flow & Encryption
  {
    id: 6,
    section: "Data Flow & Encryption",
    question: "Which of the following is NOT a purpose of the ZKPoK (Zero-Knowledge Proof of Knowledge) in the Zama protocol?",
    options: [
      "Proving the user knows the plaintext value they encrypted",
      "Preventing selective failure attacks from malformed ciphertext noise",
      "Verifying the user has sufficient token balance to pay for computation",
      "Ensuring the ciphertext is correctly constructed under the FHE public key"
    ],
    correctAnswer: 2,
    explanation: "The ZKPoK serves to: (1) prove knowledge of the plaintext, (2) prevent selective failure attacks by validating noise distribution, and (3) ensure correct ciphertext construction. Token balance verification is handled separately by the payment system, not the ZKPoK."
  },
  {
    id: 7,
    section: "Data Flow & Encryption",
    question: "How is a result handle derived after an FHE operation on the Host Chain?",
    options: [
      "Randomly generated by the Coprocessor",
      "Assigned sequentially by the TFHEExecutor contract",
      "hash(operation_type, argument_handles, chain_id) || result_type",
      "Copied from the first input handle"
    ],
    correctAnswer: 2,
    explanation: "Result handles are deterministically derived from the operation type, input handles, and chain ID. This allows the symbolic execution on-chain to compute the same handle that the Coprocessor will use to store the result."
  },
  {
    id: 8,
    section: "Data Flow & Encryption",
    question: "When a user submits encrypted input with a ZKPoK, which component performs the cryptographic verification of the zero-knowledge proof itself?",
    options: [
      "The Host Chain's InputVerifier contract",
      "The Coprocessors (off-chain)",
      "The KMS nodes",
      "The Gateway's InputVerification contract"
    ],
    correctAnswer: 1,
    explanation: "ZKPoK cryptographic verification is computationally expensive, so it's performed off-chain by Coprocessors. The Gateway's InputVerification contract only emits events to trigger verification. After verifying the proof, Coprocessors extract ciphertexts, derive handles, and sign an EIP-712 attestation."
  },
  {
    id: 9,
    section: "Data Flow & Encryption",
    question: "When FHE.fromExternal() is called on the Host Chain, what does the InputVerifier contract verify?",
    options: [
      "The ZKPoK cryptographic proof directly",
      "The Coprocessor signatures attesting that the ZKPoK was valid",
      "The plaintext value matches expected range",
      "The user's wallet balance"
    ],
    correctAnswer: 1,
    explanation: "The InputVerifier contract performs on-chain signature verification, not ZKPoK verification. It checks that a threshold of valid Coprocessor signatures attest to the handles. The inputProof contains: numHandles + numSigners + handles + coprocessorSignatures. This is an indirect verification - trusting Coprocessors' attestation that they verified the ZKPoK off-chain."
  },
  {
    id: 10,
    section: "Data Flow & Encryption",
    question: "How many FHE key pairs are used in the Zama protocol?",
    options: [
      "One key pair per application (contract)",
      "One key pair per user",
      "One global key pair shared across all applications",
      "One key pair per blockchain (Host Chain)"
    ],
    correctAnswer: 2,
    explanation: "The protocol uses a single global FHE key pair shared across all applications. This enables ciphertext composability - encrypted values from different contracts can be used together in FHE operations (when authorized via ACL). Access control is enforced by ACL contracts, not by key separation."
  },
  {
    id: 11,
    section: "Data Flow & Encryption",
    question: "Which of the following is NOT part of the auxiliary data embedded in a ZKPoK?",
    options: [
      "Chain ID",
      "User address",
      "Contract address",
      "Plaintext value"
    ],
    correctAnswer: 3,
    explanation: "The plaintext value is NEVER exposed. The auxiliary data contains: chain ID, ACL contract address, user address, contract address, and key_id. This binds the proof to a specific context without revealing the encrypted value."
  },

  // Section 3: Decryption Mechanisms
  {
    id: 12,
    section: "Decryption Mechanisms",
    question: "What is the key difference between public decryption and user decryption?",
    options: [
      "Public decryption is faster",
      "Public decryption reveals plaintext on-chain; user decryption keeps it private",
      "User decryption doesn't require KMS involvement",
      "Public decryption can be done by any user"
    ],
    correctAnswer: 1,
    explanation: "Public decryption makes the plaintext visible to everyone (e.g., for auction results). User decryption re-encrypts the result under the user's public key, so only they can decrypt it locally."
  },
  {
    id: 13,
    section: "Decryption Mechanisms",
    question: "In the public decryption flow, who calls FHE.checkSignatures() on the Host Chain?",
    options: [
      "The KMS nodes automatically",
      "The Gateway contract",
      "The user/relayer submitting the decryption result",
      "The original App contract"
    ],
    correctAnswer: 2,
    explanation: "Public decryption follows a 'self-relaying' model. Anyone can request decryption via the Relayer SDK, receive the signed plaintext from the Gateway, and then submit it to the Host Chain where FHE.checkSignatures() verifies the KMS signatures."
  },
  {
    id: 14,
    section: "Decryption Mechanisms",
    question: "Which function does a user call to authorize an App to request decryptions on their behalf?",
    options: [
      "FHE.allowDecryption()",
      "FHE.delegateUserDecryption()",
      "ACL.grantDecryptPermission()",
      "Gateway.authorizeApp()"
    ],
    correctAnswer: 1,
    explanation: "Users call FHE.delegateUserDecryption(delegate, contractAddress, expirationDate) to grant an App the right to request user decryptions. This creates an on-chain delegation in the ACL that the Gateway verifies before processing decryption requests."
  },
  {
    id: 15,
    section: "Decryption Mechanisms",
    question: "How does a user verify that a user decryption result is legitimate?",
    options: [
      "They trust the App",
      "They check the KMS signatures against known verifier addresses in the context",
      "The blockchain verifies it automatically",
      "They re-encrypt and compare"
    ],
    correctAnswer: 1,
    explanation: "The user receives decryption shares signed by KMS nodes. They verify these signatures against the key-map (KMS verifier addresses from the context) to ensure no KMS node impersonation occurred."
  },
  {
    id: 16,
    section: "Decryption Mechanisms",
    question: "Gateway decryption request IDs follow the format [kmsRequestType | keychainId | counter]. What is the purpose of including kmsRequestType?",
    options: [
      "For billing purposes",
      "To route requests to the correct KMS protocol (public/user decrypt, keygen, etc.)",
      "For logging only",
      "To identify the user"
    ],
    correctAnswer: 1,
    explanation: "The first byte identifies the request type (e.g., 1=PublicDecrypt, 2=UserDecrypt, 3=PrepKeygen, 4=Keygen, 5=CRSgen). This allows the KMS to execute the appropriate MPC protocol."
  },

  // Section 4: Service Interactions
  {
    id: 17,
    section: "Service Interactions",
    question: "Which statement about Coprocessor-Gateway communication is FALSE?",
    options: [
      "Coprocessors listen to Gateway events to receive ZKPoK verification requests",
      "Coprocessors listen to Gateway events to receive FHE computation requests",
      "Coprocessors push ACL updates to the Gateway's MultichainACL contract",
      "Coprocessors periodically pull key state information from the Gateway"
    ],
    correctAnswer: 1,
    explanation: "FHE computation requests come from the Host Chain, not the Gateway. Coprocessors listen to Host Chain events (via their embedded full node) for FHE operations. The Gateway is used for: (1) ZKPoK verification requests/responses, (2) ACL synchronization, (3) ciphertext commits, and (4) key management info. The Host Chain is where smart contracts emit FHE operation events."
  },
  {
    id: 18,
    section: "Service Interactions",
    question: "Where does the Relayer sit in the Zama protocol architecture?",
    options: [
      "Between the user and the Host Chain",
      "Between the user and the Gateway",
      "Between the user and the Coprocessor",
      "Between the Coprocessor and the Gateway"
    ],
    correctAnswer: 1,
    explanation: "The Relayer sits between the user and the Gateway. It abstracts all Gateway interactions so users only need a Host Chain wallet. The Relayer forwards ZKPoK verification requests, handles decryption coordination, and pays Gateway gas on the user's behalf."
  },
  {
    id: 19,
    section: "Service Interactions",
    question: "Which event type does the Coprocessor's Host Listener NOT handle?",
    options: [
      "TFHE operation events",
      "ACL allow/delegate events",
      "ZKPoK verification requests",
      "Decryption request events"
    ],
    correctAnswer: 2,
    explanation: "ZKPoK verification requests come from the Gateway (handled by GW Listener), not the Host Chain. The Host Listener handles TFHE operations, ACL events, and decryption requests - all emitted by Host Chain contracts. Input verification flows through the Gateway first."
  },
  {
    id: 20,
    section: "Service Interactions",
    question: "What does the KMS Connector do?",
    options: [
      "Connects users to their wallets",
      "Interfaces between the Gateway and KMS Core, forwarding cryptographic requests",
      "Connects different KMS nodes together",
      "Manages database connections"
    ],
    correctAnswer: 1,
    explanation: "The KMS Connector picks up events (like decryption requests) from the Gateway via a GW Listener and forwards them to the KMS Core for MPC execution. It then relays responses back to the Gateway."
  },
  {
    id: 21,
    section: "Service Interactions",
    question: "How many Coprocessors does Zama operate as of early 2026?",
    options: [
      "1 (single trusted operator)",
      "5 (majority consensus)",
      "13 (same as KMS nodes)",
      "Unlimited (permissionless)"
    ],
    correctAnswer: 0,
    explanation: "As of early 2026, Zama operates a single trusted Coprocessor. The architecture is designed to support multiple Coprocessors with majority consensus, and Zama plans to expand to 5 Coprocessors within the quarter. Eventually, Coprocessors will stake tokens and can be slashed for misbehavior."
  },

  // Section 5: Advanced Concepts
  {
    id: 22,
    section: "Advanced Concepts",
    question: "According to NIST SP 800-57 (followed by Zama), which key state still allows FHE computation and key switching, but NOT new key rotations?",
    options: [
      "Active",
      "Suspended",
      "Deactivated",
      "Pre-activation"
    ],
    correctAnswer: 1,
    explanation: "Suspended is a temporary state when a key is replaced by a new Active key. It still allows inputs, FHE computation, decryption, and being a target for key switching - but no new key rotations can be launched from it. Deactivated only allows decryption. This ensures no service disruption during key transitions."
  },
  {
    id: 23,
    section: "Advanced Concepts",
    question: "How does the Zama protocol handle key rotation for existing ciphertexts?",
    options: [
      "All ciphertexts must be re-encrypted manually",
      "Key Switching Keys (KSK) convert ciphertexts on-demand during computation",
      "Old ciphertexts become permanently inaccessible",
      "A migration ceremony decrypts and re-encrypts all data"
    ],
    correctAnswer: 1,
    explanation: "Zama uses FHE key switching. When a computation involves ciphertexts encrypted under older keys, the Coprocessor uses KSKs to convert them to the current key 'just-in-time' during execution."
  },
  {
    id: 24,
    section: "Advanced Concepts",
    question: "AWS Nitro Enclaves in TKMS protect key shares from which threat?",
    options: [
      "Network attackers intercepting traffic between KMS nodes",
      "Malicious smart contracts on the Host Chain",
      "The KMS node operator themselves accessing the key material",
      "Coprocessors submitting fraudulent computation results"
    ],
    correctAnswer: 2,
    explanation: "Nitro Enclaves create an isolated execution environment where even the node operator (with root access to the host machine) cannot access the key shares. The enclave's memory is encrypted and inaccessible from outside. Network security and smart contract threats are handled by other mechanisms."
  },
  {
    id: 25,
    section: "Advanced Concepts",
    question: "What is the role of tfhe-rs in the Zama ecosystem?",
    options: [
      "A JavaScript SDK for web developers",
      "The core Rust library implementing TFHE cryptographic primitives used by Coprocessors",
      "A smart contract compiler",
      "A blockchain consensus mechanism"
    ],
    correctAnswer: 1,
    explanation: "tfhe-rs is the cryptographic foundation implementing LWE/GLWE-based TFHE. It provides Programmable Bootstrapping (PBS), keyswitching, and the FheUint/FheBool types. Coprocessors use it for all FHE computations."
  },
  {
    id: 26,
    section: "Advanced Concepts",
    question: "Why is random 'noise' added to TFHE ciphertexts during encryption?",
    options: [
      "To compress the ciphertext size",
      "To make the encryption secure (without noise, encryption could be broken)",
      "To speed up homomorphic operations",
      "To enable key rotation between versions"
    ],
    correctAnswer: 1,
    explanation: "Noise is essential for security - without it, TFHE encryption could be broken. The noise is encoded in the least significant bits of the ciphertext. The tradeoff: each operation increases noise, and if it grows too large it corrupts the message."
  },
  {
    id: 27,
    section: "Advanced Concepts",
    question: "What problem does Programmable Bootstrapping (PBS) solve in TFHE?",
    options: [
      "It generates the initial encryption keys",
      "It resets noise to prevent it from corrupting results",
      "It compresses ciphertexts to reduce storage",
      "It converts ciphertexts between different key versions"
    ],
    correctAnswer: 1,
    explanation: "Noise grows with each FHE operation. If it gets too large, it corrupts the encrypted result. PBS resets noise back to a safe level, allowing more operations to be performed. Without PBS, you'd hit a noise limit and need to decrypt early."
  },
  {
    id: 28,
    section: "Advanced Concepts",
    question: "Why would you re-randomize a ciphertext before using it in an FHE computation?",
    options: [
      "To make the ciphertext smaller",
      "To prevent attackers from learning information by observing repeated computations",
      "To convert it to a newer key version",
      "To reduce the noise level"
    ],
    correctAnswer: 1,
    explanation: "Re-randomization adds fresh randomness to a ciphertext. Without it, an attacker observing the same ciphertext used multiple times could potentially learn information about the plaintext. It's a security hardening measure for sensitive computations."
  },
  {
    id: 29,
    section: "Advanced Concepts",
    question: "According to Zama's whitepaper benchmarks, approximately how long does a 64-bit encrypted multiplication take on GPU (2x NVIDIA H100)?",
    options: [
      "~1 ms",
      "~20 ms",
      "~170 ms",
      "~400 ms"
    ],
    correctAnswer: 2,
    explanation: "A euint64 multiplication takes approximately 166ms on GPU (2x H100). GPU acceleration provides roughly 2-3x speedup for complex operations like multiplication compared to CPU."
  },
  {
    id: 30,
    section: "Advanced Concepts",
    question: "According to Zama's whitepaper benchmarks, approximately how long does a 64-bit encrypted addition take on CPU (AMD EPYC 9R14)?",
    options: [
      "~10 ms",
      "~50 ms",
      "~110 ms",
      "~400 ms"
    ],
    correctAnswer: 2,
    explanation: "A euint64 addition takes approximately 109ms on CPU (AMD EPYC 9R14 with 192 cores). Addition is faster than multiplication but slower than bitwise operations. On GPU, addition drops to ~20ms."
  },
  {
    id: 31,
    section: "Advanced Concepts",
    question: "Which FHE operation is fastest according to Zama's whitepaper benchmarks?",
    options: [
      "Multiplication",
      "Division",
      "Comparison (less than)",
      "Bitwise AND/OR"
    ],
    correctAnswer: 3,
    explanation: "Bitwise operations (AND/OR) are the fastest at ~19-23ms on CPU and ~3-4ms on GPU for euint64. This is because they don't require Programmable Bootstrapping, unlike arithmetic operations which are significantly slower."
  },
];

export const sections = [
  "Architecture & Components",
  "Data Flow & Encryption", 
  "Decryption Mechanisms",
  "Service Interactions",
  "Advanced Concepts"
];
